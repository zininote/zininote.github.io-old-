---
layout: post
title: "53. Maximum Subarray"
updated: 2021-12-21
tags: [leetcode,design,dynamic_programming,divide_and_conquer]
---

## 문제

[https://leetcode.com/problems/maximum-subarray/description/](https://leetcode.com/problems/maximum-subarray/description/)

주어지는 nums 배열에서, 연속된 수들로 부분합을 구했을 때, 가장 큰 값을 리턴하는 문제다.

## Brute Force

```python
def maxSubArray(self, nums: List[int]) -> int:
    subs = []
    for i in range(len(nums)):
        tmp = []
        for x in nums[i:]:
            tmp += [(tmp[-1] if tmp else 0) + x]
        subs += [max(tmp)]
    
    return max(subs)
```
{:.python}

이중루프로 구현했다. 첫번째 루프에서 부분합을 구할 시작인덱스 i 를 정하면, 두번째 루프에서 i 인덱스 이후를 순회하면서 나올 수 있는 부분합을 모두 구한 뒤, 가장 큰 값을 저장해둔다.

마지막에는 각 i 인덱스로부터의 부분합들 중 가장 큰 값을 리턴하는 구조다.

이 방식은 시간초과로 문제를 통과할 수 없었다.

## Dynamic Programming (Kadane's Algorithm)

```python
def maxSubArray(self, nums: List[int]) -> int:
    subs = []

    for i, x in enumerate(nums):
        if i == 0:
            subs += [nums[0]]
        else:
            subs += [max(nums[i], subs[i-1]+nums[i])]

    return max(subs)
```
{:.python}

점화식으로 나타낼 수 있는 풀이는 Dynamic Programming 알고리즘을 적용하기가 쉽다. 이 문제의 점화식은 아래와 같다.

```pseudo
# subs[i] 는 nums 배열의 인덱스 i 까지의 최대부분합

subs[0] = nums[0]                            # Initial Value
subs[i] = max(nums[i], subs[i-1]+nums[i])    # Recurrence Equation
```
{:.pseudo}

Brute Force 풀이에서는 i 부터의 최대값을 구하는 것에 반해, Kadane's Algorithm 에서는 i 까지의 부분합을 구하는 방식이다.

i 의 부분합이 최대가 되려면, i-1 까지의 최대값에 nums[i] 를 더한것이 최대가 되는지 아닌지만 알면 되기에 위와 같은 점화식이 구현된다.

시간은 792 ms 였다.

## Divide and Conquer

```python
def maxSubArray(self, nums: List[int]) -> int:

    def fn(A):
        if len(A) == 1: return A[0], A[0], A[0], A[0]

        m = len(A)//2
        ll, lm, lr, lt = fn(A[:m])
        rl, rm, rr, rt = fn(A[m:])

        return max(ll, lt+rl), max(lm, lr+rl, rm), max(lr+rt, rr), lt+rt

    return fn(nums)[1]
```
{:.python}

nums 를 계속 둘로 쪼개고 난 뒤, 쪼개진 부분배열들을 다시 조립할 때 최대부분합을 계속 갱신해가는 구조다. 아래와 같이 이해할 수 있다.

```pseudo

```
{:.pseudo}

시간은 1212 ms 였다.